---
icon: ri:plug-line
---

#  Plugins

Use plugins to extend Nitro's runtime behavior.

Plugins are auto-registered (filename ordering) and run synchronously on the first nitro initialization. They receive `nitroApp` context, which can be used to hook into lifecycle events.

Scanning pattern: `plugins/**/*.{ts,mjs,js,cjs}`

You can order the plugins by prefixing them with a number:

```md
plugins/
  1.first.ts
  2.second.ts
```

**Example:** Simple plugin

```ts
// plugins/test.ts
export default defineNitroPlugin((nitroApp) => {
  console.log('Nitro plugin', nitroApp)
})
```

**Example:** Development Plugin

You can use plugins to run development tasks, such as database migrations.

```ts
import { migrate } from 'drizzle-orm/better-sqlite3/migrator'

export default defineNitroPlugin(() => {
  if (process.dev) {
    migrate(useDb(), { migrationsFolder: './migrations' })
  }
})
```

**Example:** Hooks

You can use plugins to modify the response or run tasks when Nitro is closed.

```ts
export default defineNitroPlugin((nitro) => {
  nitro.hooks.hookOnce("close", async () => {
    // Will run when nitro is closed
    await new Promise((resolve) => setTimeout(resolve, 500));
    console.log("Task is done!");
  });
  nitro.hooks.hook('render:response', (response) => {
    // Modify the renderer response here
    console.log(response)
  })
})
```

If you have plugins in another directory, you can use the `plugins` option:

::code-group
```ts [nitro.config.ts]
import { defineNitroConfig } from 'nitropack/config'

export default defineNitroConfig({
  plugins: ['my-plugins/hello.ts']
})
```
```ts [nuxt.config.ts]
export default defineNuxtConfig({
  nitro: {
    plugins: ['my-plugins/hello.ts']
  }
})
```
::
